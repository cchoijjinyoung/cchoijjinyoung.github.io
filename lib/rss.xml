<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>Obsidian Vault</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 04 Mar 2025 15:52:16 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 04 Mar 2025 15:52:16 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Spring security의 oauth2-client 라이브러리 동작 방식]]></title><description><![CDATA[ 
 <br><br>
<br>클라이언트의 '구글 로그인' 버튼 클릭

<br>localhost:8080/oauth2/authorize/google?redirect_uri=localhost:11078/oauth 요청


<br>서버는 해당 요청을 받아서 사용자를 구글의 인증 URL로 <a data-tooltip-position="top" aria-label="^cb9892" data-href="#^cb9892" href="about:blank#^cb9892" class="internal-link" target="_self" rel="noopener nofollow">redirect</a> 시킨다.

<br>위 동작은 OAuth2AuthorizationRequestRedirectFilter가 수행한다.

<br>수행 내용을 간략하게 설명하면, 들어온 요청을 바탕으로 OAuth2AuthorizationRequest 객체를 만들어내고 구글(혹은 다른 리소스 서버)에게 인증을 요청한다.


<br>authorizationRequestRepository는 구글로 redirection 되기 직전에 인증 요청을 저장한다.
<br>redirection 할 때, OAuth2 인증 요청에 필요한 여러 정보를 URL에 쿼리 파라미터로 담아 구글로 전달한다.(client_id, redirect_uri, scope, state 등)
<br>구글은 해당 요청에 포함된 client_id, redirect_uri등이 유효한지 검증하고, 사용자가 이미 로그인되어 있는지 확인한다. 로그인되어 있지 않으면, 로그인 폼을 보여준다.


<br>사용자가 구글 로그인 폼에서 로그인에 성공하면, 구글은 쿼리 파라미터에 포함했던 redirect_uri로 리디렉션 시키며, 쿼리 파라미터에 authorization code를 포함하여 redirection 시킨다.
<br>서버는 authorization code를 사용하여  access token을 발급하기 위해 '구글 인증 서버'에 요청을 보낸다.

<br>이 때, 리디렉션 요청을 OAuth2LoginAutenticationFilter가 가로채고 해당 authorization_code를 구글의 '토큰 발급 uri'로 요청하여 access token을 받게 된다.
<br>스프링 시큐리티에서 'google, github, facebook'의 토큰 발급 uri는 기본적으로 제공해준다. 하지만 'naver'나 'kakao'에 대해서는 제공해주지 않기 때문에 application.yml과 같은 설정파일에 작성해주어야한다.
<br>작성된 정보는 clientRegistration.providerDetails필드에 담긴다.
<br>


<br>구글은 authorization code를 검증하고, access token을 Authorization 헤더에 담아 응답한다.
<br>서버는 발급 받은 access token으로 '구글 리소스 서버' 로부터 회원 정보를 요청하고 응답받는다.
<br><br><br><br><br>
<br>서버가 클라이언트에게 3xx 상태코드와 함께 새 URL을 알려준다.
<br>클라이언트는 해당 응답을 받아 새 URL로 다시 응답을 보낸다.
<br>이전의 요청데이터가 유지 되지 않으므로, URL 파라미터나 쿠키 등을 사용해야한다.
<br><br>
<br>서버가 클라이언트의 요청을 내부적으로 다른 자원(e.g JSP나 다른 Servlet)으로 전달한다.
<br>클라이언트가 새 URL로 요청을 하는 것이 아니기 때문에, 브라우저의 URL이 변경되지 않는다.
<br>서버 내부적으로만 처리되므로 하나의 request에서 모든 처리가 완료된다. 따라서 request 객체에 담긴 데이터가 유지된다.
<br><br>^1d4a03<br>
state는 CSRF(Cross-Site Request Forgery) 공격을 방지하기 위해 사용되는 임의의 문자열이다. 서버는 이 값을 authorizationRequestRepository에 저장한 후, 구글로 redirection 시 포함하여 전송한다.<br>이후 사용자가 구글에서 인증을 완료하고 돌아올 때, 같은 state 문자열값이 포함되어 돌아오므로, 서버는 이 값이 이전에 저장했던 state와 일치하는지 확인하여 요청의 무결성을 검증하게 된다.<br><br>^7b895b<br>
<img alt="스크린샷 2024-11-09 15.39.12.png" src="lib/media/스크린샷-2024-11-09-15.39.12.png"><br>
대강 흐름을 보면, 들어온 요청을 통해 새로운 request 객체를 생성하고, sendRedirectForAuthorization(~) 을 호출하는 것으로 확인된다.<br>
OAuth2 인증 흐름을 생각해보면, 리소스 서버의 '로그인 폼'으로 redirect 시키는 동작을 할 것으로 예상된다. 예상한 결과가 맞을지 자세히 들여다보자.<br>
<br>OAuth2AuthorizationRequest authorizationRequest = this.authorizationRequestResolver.resolve(request)<br>
들어온 요청으로 resolve(request)를 통해 OAuth2AuthorizationRequest 객체를 생성하는 것을 볼 수 있다.<br>
resolve 메서드는 무슨 동작을 할 지 살펴보자.
<br>DefaultOAuth2AuthorizationRequestResolver.resolve(HttpServletRequest request)<img alt="스크린샷 2024-11-09 15.45.01.png" src="lib/media/스크린샷-2024-11-09-15.45.01.png"><br>
String registrationId = resolveRegistrationId(request);는 요청 파라미터의 registrationId의 값을 가져온다.(e.g "google")<br>
String redirectUriAction = getAction(request, "login"); 는 내부적으로 action이라는 파라미터가 존재하는지 확인하고, 없으면 "login"을 반환하는 메서드다.<br>따라서 결국에 resolve(request, "google", "login"); 을 호출 및 반환하게 된다.<img alt="스크린샷 2024-11-09 16.11.08.png" src="lib/media/스크린샷-2024-11-09-16.11.08.png"><br>
마지막 resolve 메서드를 살펴보면 OAuth2AuthorizaionRequestBuilder 를 통해 최종적으로 우리가 원하는 request를 만들어내는 것으로 보인다.<br>
주요하게 볼 점은 ClientRegistration 클래스이다.<br>ClientRegistration 객체가 갖는 정보는 clientId, clientSecret, redirectUri 등으로 리소스 서버별 인증 시 필요한 정보들을 담고 있다.(e.g 구글 소셜 로그인 시 필요한 정보들을 담고 있다.)<br>
ClientRegistration 객체는 우리 애플리케이션을 실행할 때, 자동으로 생성되는데,<br>
스프링이 내부적으로 application.yml 설정을 참고하여 생성한다.<br>
만들어진 객체는 ClientRegistrationRepository의 Map에 저장해놓는다. Map&lt;String, ClientRegistration&gt;<br>
Key는 "google" 와 같이 리소스 서버의 이름으로 되어 있다.<br>돌아와서, <img alt="4.png" src="lib/media/4.png"><br>
방금까지 빨간 박스로 씌워진 Request 객체가 생성되는 과정을 보았으니,<br>
this.sendRedirectForAuthorization(request, response, authorizationRequest); 부분을 보자.<br>
<img alt="스크린샷 2024-11-11 19.54.42.png" src="lib/media/스크린샷-2024-11-11-19.54.42.png"><br>
우리는 OAuth2의 자격 증명 방식 중 'Authorization Code' 방식을 다루고 있으므로, if 문의 authorizationRequestRepository.saveAuthorizationRequest(authorizationRequest, request, response);라인을 실행할 것이다.<br>
위에 동작 과정에서 잠깐 다뤘듯, authorizationRequestRepository가 요청 정보를 저장하는 것을 확인할 수 있다.<br>내부 동작을 더 자세하게 보면,<br>
<img alt="6.png" src="lib/media/6.png"><br>
request.getSession().setAttribute(this.sessionAttributeName, authorizationRequest); 로 요청 정보를 세션에 저장하게 된다.<br>
추후에 세션에서 저장된 요청 정보를 가져와서 state 파라미터로 유효한 요청인지 검증하게 된다.<br>이렇게 요청 정보를 세션에 저장하고 난 뒤, 이전 메서드로 돌아가면 authorizationRequest의 authorizationRequestUri로 리디렉션시키는데,<br>
해당 Uri에서 구글은 clientId, redirectUri 등을 검증하고 유효하면 사용자를 로그인 폼으로 리디렉션 시키게 된다.<br>사용자는 로그인 폼에서 아이디/패스워드를 입력해서 로그인을 하게되고, 구글은 사용자가 로그인에 성공하면, authorization_code를 쿼리 파라미터에 포함시켜 우리 서버의redirect_uri로 리디렉션시킨다.<br><br>OAuth2LoginAuthenticationFilter는 redirect_url + authorziation_code 로 들어오는 요청을 가로채는 필터이다.<br>
이 필터에서는 authorization_code를 통해 리소스 서버로부터 access_token을 발급해오는 과정이 진행된다.<br>필터의 수행을 쭉 살펴보면,<br>
첫번째로는 request와 response를 검증하게되는데, response가 null일 땐,IllegalArgumentException을 던진다.<br>
request에 대해서 검증을 할 때는 code, state, error, state 라는 파라미터가 포함되는지 확인한 후, 우리가 세션에 저장했던 요청 정보를 통해 안전한 요청인지 검증하게 된다.<br>
code파라미터는 우리가 발급받은 authorization_code를 담고 있는 파라미터 이름이다.
request 검증 시, state라는 파라미터가 존재해야하고, 존재한다면 이번 요청의 state와 세션의 state가 같아야만 한다.
<br>요청의 검증을 완료했으면, authorization_code를 발급받아올 때, 세션에 저장해뒀던 정보 안에 존재하는 registrationId(e.g "google")를 통해 ClientRegistration(소셜 로그인 시 필요한 정보를 담은 클래스) 객체를 찾아온다.(존재하지 않을 시, throw CLIENT_REGISTRATION_NOT_FOUND_ERROR)<br>이제 authorization_code로 access_token을 발급받아오기 위해, 또 새로운 request를 만들어낼 차례이다.<br>
<img alt="8.png" src="lib/media/8.png"><br>
코드를 보면, redirectUri와 OAuth2AuthorizationResponse 객체로 OAuth2LoginAuthenticationToken을 생성한다.<br>
스프링 시큐리티에서 Token은 인증을 위한 서류라고 생각하면 쉽다. 또한 이 서류는 '아직 인증되지 않은 서류'와 '인증된 서류'로 생성자가 나뉜다.<br>
그래서 스프링 시큐리티의 인증 흐름은 '인증되지 않은 토큰'을 생성 후에 '인증 Provider'에게 해당 서류를 넘겨 검토를 받은 후 '인증된 서류'로 새롭게 생성되는 과정이 동반된다.<br>
<img alt="9.png" src="lib/media/9.png">
<br>내부 로직을 파고들면 아래의 클래스들이 나온다. 주요 클래스 및 기능만 가져왔다.<br><br>
<br>access_token 발급과 userInfo를 조회해오는 클래스
<br>access_token의 발급은 내부에서 실질적으로 OAuth2AuthorizationCodeAuthenticationProvider 클래스가 수행하게된다.
<br>access token OAuth2AccessToken이라는 클래스로 관리되는데, 이 클래스는 Set&lt;String&gt; scopes라는 필드를 갖고 있다. scope는 사용자의 profile, email등을 나타낸다. 즉, 해당 토큰이 scopes에 접근할 수 있는 토큰임을 의미한다.
<br><br>
<br>OAuth2LoginAuthenticationProvider 내부에서 access_token으로 userInfo를 실질적으로 조회해오는 클래스 및 메서드
<br>스프링 시큐리티는 외부 API를 호출할 때, RequestEntity와 RestTemplate를 사용한다. 
<br>우리가 지금껏 만들어낸 Request 객체를 RequestEntity로 convert한 후 RestTemplate를 사용하여 외부 API를 호출하게된다.(restOperations.exchange(request);)
<br>(참고) 내부 코드를 파고든다면, userNameAttributeName이라는 변수명을 볼 수 있다. 이는 각 리소스 서버별로 사용자의 고유 식별자를 담고 있는 필드 이름을 제공하는데, 그 필드 이름을 의미한다.(e.g 구글 : "sub", 카카오 : "id")
<br>마지막으로 다시 필터로 돌아가보자.<br>
<img alt="10.png" src="lib/media/10.png"><br>
지금까지 authorization_code와 다른 요청정보로 access_token과 userInfo를 가져왔다.<br>
마지막 코드는 토큰들을 포함한 인증 정보를 저장하는 코드인데, access_token이 유효한 동안은 추가 인증 없이 계속해서 리소스 서버에 userInfo를 요청할 수 있게 된다.]]></description><link>블로깅/spring-security의-oauth2-client-라이브러리-동작-방식.html</link><guid isPermaLink="false">블로깅/Spring security의 oauth2-client 라이브러리 동작 방식.md</guid><pubDate>Wed, 13 Nov 2024 21:04:44 GMT</pubDate><enclosure url="lib/media/스크린샷-2024-11-09-15.39.12.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/스크린샷-2024-11-09-15.39.12.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>